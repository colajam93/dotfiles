#!/usr/bin/env python3

import argparse
import subprocess
import re
import sys
import collections
from typing import List, Dict
import socket

LIST, LIST_VMS, START, POWEROFF, LOGIN, CLONE, REMOVE, SNAPSHOT, TAKE, RESTORE = (
    'list', 'list-vms', 'start', 'poweroff', 'login', 'clone', 'remove', 'snapshot', 'take', 'restore')
V_BOX_MANAGE = 'VBoxManage'


class VBoxCtlError(Exception):
    def __init__(self, message) -> None:
        self.message = message


def list_vms():
    return run_for_output([V_BOX_MANAGE, LIST, 'vms']).strip()


def list_running_vms():
    return run_for_output([V_BOX_MANAGE, LIST, 'runningvms']).strip()


def parse_v_box_manage_list_output(output):
    pattern = re.compile(
        r'"(?P<name>.+)" '
        r'{(?P<uuid>[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})}')
    m = re.match(pattern, output)
    if not m:
        raise VBoxCtlError(f'cannot parse {output}')
    vm_item = collections.namedtuple('VMItem', ['name', 'uuid'])
    return vm_item(name=m.group('name'), uuid=m.group('uuid'))


def run_with_exit_code(command):
    completed = subprocess.run(command)
    sys.exit(completed.returncode)


def run_for_output(command: List[str]) -> str:
    completed = subprocess.run(command, stdout=subprocess.PIPE)
    return completed.stdout.decode()


def do_list_common(args, list_func):
    vms = list_func()
    if not vms:
        sys.exit(0)
    try:
        vm_names = map(parse_v_box_manage_list_output, vms.split('\n'))
    except ValueError:
        sys.exit(1)
    if args.name:
        for n in vm_names:
            print(n.name)
    elif args.uuid:
        for n in vm_names:
            print(n.uuid)
    else:
        for n in vm_names:
            print('"{}" {{{}}}'.format(n.name, n.uuid))


def do_list(args):
    do_list_common(args, list_running_vms)


def do_list_vms(args):
    do_list_common(args, list_vms)


def do_start(args):
    if args.with_gui:
        start_type = 'gui'
    else:
        start_type = 'headless'

    command = [V_BOX_MANAGE, 'startvm', args.target, '--type', start_type]
    run_with_exit_code(command)


def do_poweroff(args):
    if args.force:
        subcommand = 'poweroff'
    else:
        subcommand = 'acpipowerbutton'

    command = [V_BOX_MANAGE, 'controlvm', args.target, subcommand]
    run_with_exit_code(command)


def parse_config(raw: str) -> Dict[str, str]:
    r = {}
    key_value = re.compile(r'^(?P<k>.*)=(?P<v>.*)$')
    string_literal = re.compile(r'^"(?P<v>.*)"$')
    for l in raw.split('\n'):
        m = re.match(key_value, l)
        assert m
        k = m.group('k')
        v = m.group('v')
        m = re.match(string_literal, k)
        if m:
            key = m.group('v')
        else:
            key = k

        m = re.match(string_literal, v)
        if m:
            r[key] = m.group('v')
        else:
            r[key] = v
    return r


class NicConfig:
    def __init__(self, nic_number: int, nic_type: str, mac_address: str) -> None:
        self.nic_number = nic_number
        self.nic_type = nic_type
        self.mac_address = mac_address


def parse_nic_configs(conf: Dict[str, str]) -> List[NicConfig]:
    r = []
    for i in range(1, 9):
        nic_type = conf[f'nic{i}']
        if nic_type == 'none':
            continue
        mac_address = conf[f'macaddress{i}']
        r.append(NicConfig(i - 1, nic_type, mac_address))
    return r


def nic_configs(target: str) -> List[NicConfig]:
    raw_config = run_for_output([V_BOX_MANAGE, 'showvminfo', '--machinereadable', target]).strip()
    config = parse_config(raw_config)
    return parse_nic_configs(config)


def guest_property(property_: str, target: str) -> str:
    raw = run_for_output(
        [V_BOX_MANAGE, 'guestproperty', 'get', target, property_]).strip()
    p = re.compile(r'^Value: (?P<v>.*)$')
    m = re.match(p, raw)
    if m:
        return m.group('v')
    else:
        raise VBoxCtlError(f'vm {target} does not have the property f{property_}')


def nic_ip_address(nic_config: NicConfig, target: str) -> str:
    nic_count = int(guest_property('/VirtualBox/GuestInfo/Net/Count', target))
    for i in range(nic_count):
        mac_ = guest_property(f'/VirtualBox/GuestInfo/Net/{i}/MAC', target)
        if mac_ == nic_config.mac_address:
            return guest_property(f'/VirtualBox/GuestInfo/Net/{i}/V4/IP', target)
    raise VBoxCtlError(f'NIC {nic_config.mac_address} has no IP address')


def is_listening_ssh(address: str) -> bool:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(0.01)
    try:
        s.connect((address, 22))
        header = s.recv(64).decode()
        if header.startswith('SSH-2.0-'):
            return True
        return False
    except (ConnectionError, socket.timeout):
        return False


def is_running(target: str) -> bool:
    raw_vms = list_running_vms().strip()
    if not raw_vms:
        return False
    vms = map(parse_v_box_manage_list_output, raw_vms.split('\n'))
    for vm in vms:
        if vm.name == target:
            return True
    return False


# TODO: add option for NIC, IP, Key, ...
def do_login(args) -> None:
    if not is_running(args.target):
        raise VBoxCtlError(f'vm {args.target} is not running')
    nic_configs_ = nic_configs(args.target)
    if len(nic_configs_) == 0:
        raise VBoxCtlError(f'vm {args.target} has no network interface')

    for i in nic_configs_:
        if i.nic_type == 'hostonly' or i.nic_type == 'bridged':
            try:
                address = nic_ip_address(i, args.target)
            except VBoxCtlError:
                continue
            if is_listening_ssh(address):
                command = ['ssh', address]
                run_with_exit_code(command)

    raise VBoxCtlError(f'There is no SSH server on vm {args.target}')


def do_clone(args):
    command = [V_BOX_MANAGE, 'clonevm', args.target, '--mode', 'machine', '--name', args.name, '--register']
    run_with_exit_code(command)


def show_confirm(message: str, default_yes: bool = False, hide_yn: bool = False) -> bool:
    prompt = ' [y/N]'
    if hide_yn:
        prompt = ''
    elif default_yes:
        prompt = ' [Y/n]'
    mes = f'{message}{prompt} '

    input_ = ''
    try:
        input_ = input(mes)
    except EOFError:
        pass

    if input_ == '':
        result = default_yes
    else:
        result = input_.lower() == 'y' or input_.lower() == 'yes'
    return result


def do_remove(args):
    confirm_ = args.force
    if not confirm_:
        confirm_ = show_confirm(message=f"Are you sure to remove '{args.target}'?")
    if confirm_:
        command = [V_BOX_MANAGE, 'unregistervm', args.target, '--delete']
        run_with_exit_code(command)


def do_snapshot_list(args):
    command = [V_BOX_MANAGE, SNAPSHOT, args.target, LIST]
    run_with_exit_code(command)


def do_snapshot_take(args):
    command = [V_BOX_MANAGE, SNAPSHOT, args.target, TAKE, args.name]
    run_with_exit_code(command)


def do_snapshot_restore(args):
    confirm_ = args.force
    if not confirm_:
        confirm_ = show_confirm(message=f"Are you sure to remove '{args.name}'?")
    if confirm_:
        command = [V_BOX_MANAGE, SNAPSHOT, args.target, RESTORE, args.name]
        run_with_exit_code(command)


def do_snapshot_remove(args):
    confirm_ = args.force
    if not confirm_:
        confirm_ = show_confirm(message=f"Are you sure to restore '{args.name}'?")
    if confirm_:
        command = [V_BOX_MANAGE, SNAPSHOT, args.target, 'delete', args.name]
        run_with_exit_code(command)


def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command')
    subparsers.required = True

    def setup_list_parser(subparsers):
        desc = 'show running vm list'
        parser_list = subparsers.add_parser(LIST, description=desc, help=desc)
        group = parser_list.add_mutually_exclusive_group()
        group.add_argument('-n', '--name', action='store_true', help='show name only')
        group.add_argument('-u', '--uuid', action='store_true', help='show uuid only')
        parser_list.set_defaults(func=do_list)

    setup_list_parser(subparsers)

    def setup_list_vms_parser(subparsers):
        desc = 'show vm list'
        parser_list_vms = subparsers.add_parser(LIST_VMS, description=desc, help=desc)
        group = parser_list_vms.add_mutually_exclusive_group()
        group.add_argument('-n', '--name', action='store_true', help='show name only')
        group.add_argument('-u', '--uuid', action='store_true', help='show uuid only')
        parser_list_vms.set_defaults(func=do_list_vms)

    setup_list_vms_parser(subparsers)

    def setup_start_parser(subparsers):
        desc = 'start vm'
        parser_start = subparsers.add_parser(START, description=desc, help=desc)
        parser_start.add_argument('target', help='vm name')
        parser_start.add_argument('-g', '--with-gui', action='store_true', help='start with gui window')
        parser_start.set_defaults(func=do_start)

    setup_start_parser(subparsers)

    def setup_poweroff_parser(subparsers):
        desc = 'poweroff vm'
        parser_poweroff = subparsers.add_parser(POWEROFF, description=desc, help=desc)
        parser_poweroff.add_argument('target', help='vm name')
        parser_poweroff.add_argument('-f', '--force', action='store_true',
                                     help="use 'poweroff' instead of 'acpipowerbutton'")
        parser_poweroff.set_defaults(func=do_poweroff)

    setup_poweroff_parser(subparsers)

    def setup_login_parser(subparsers):
        parser_login = subparsers.add_parser(LOGIN, description="execute 'ssh target'", help='login vm')
        parser_login.add_argument('target', help='vm name')
        parser_login.set_defaults(func=do_login)

    setup_login_parser(subparsers)

    def setup_clone_parser(subparsers):
        desc = 'clone vm'
        parser_clone = subparsers.add_parser(CLONE, description=desc, help=desc)
        parser_clone.add_argument('target', help='source vm name')
        parser_clone.add_argument('name', help='destination vm mane')
        parser_clone.set_defaults(func=do_clone)

    setup_clone_parser(subparsers)

    def setup_remove_parser(subparsers):
        desc = 'remove vm'
        parser_remove = subparsers.add_parser(REMOVE, description=desc, help=desc)
        parser_remove.add_argument('target', help='vm name')
        parser_remove.add_argument('-f', '--force', action='store_true', help='remove vm without confirmation')
        parser_remove.set_defaults(func=do_remove)

    setup_remove_parser(subparsers)

    def setup_snapshot_parser(subparsers):
        desc = 'snapshot operation'
        parser_snapshot = subparsers.add_parser(SNAPSHOT, description=desc, help=desc)
        parser_snapshot.add_argument('target', help='vm name')
        third_parsers = parser_snapshot.add_subparsers(dest='subcommand')
        third_parsers.required = True

        list_help = 'list snapshot'
        parser_list = third_parsers.add_parser(LIST, description=list_help, help=list_help)
        parser_list.set_defaults(func=do_snapshot_list)

        take_help = 'take snapshot'
        parser_take = third_parsers.add_parser(TAKE, description=take_help, help=take_help)
        parser_take.add_argument('name', help='snapshot name')
        parser_take.set_defaults(func=do_snapshot_take)

        restore_help = 'restore snapshot'
        parser_restore = third_parsers.add_parser(RESTORE, description=restore_help, help=restore_help)
        parser_restore.add_argument('name', help='snapshot name')
        parser_restore.add_argument('-f', '--force', action='store_true', help='restore snapshot without confirmation')
        parser_restore.set_defaults(func=do_snapshot_restore)

        remove_help = 'remove snapshot'
        parser_remove = third_parsers.add_parser(REMOVE, description=remove_help, help=remove_help)
        parser_remove.add_argument('name', help='snapshot name')
        parser_remove.add_argument('-f', '--force', action='store_true', help='remove snapshot without confirmation')
        parser_remove.set_defaults(func=do_snapshot_remove)

    setup_snapshot_parser(subparsers)

    args = parser.parse_args()
    args.func(args)


if __name__ == '__main__':
    main()
